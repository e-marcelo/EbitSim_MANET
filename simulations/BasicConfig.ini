##
### Include Parent Config
###
include omnetpp.ini

###
### Basic configuration for scenarios using the ClientController
###
[Config Base]
network = BasicTopology
seed-set = ${runnumber}


#Medidas de desempeño -> Periodo de calentamiento (SLAW)
warmup-period = 72h


#Verificar que no se requiera mucho espacio en el disco duro para almacenamiento de datos
record-eventlog = false

#Verificar que no se requiera mucho espacio en el disco duro para almacenamiento de datos -> :(
#record-eventlog =true

#Área de simulación
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 500m
**.constraintAreaMaxY = 500m
**.constraintAreaMaxZ = 0m
**.mobility.initFromDisplayString = false
**.debug = false
**.coreDebug = false


## TCP
**.tcp.mss = 536 # bigger size?
**.tcp.tcpAlgorithmClass = "TCPReno"
#**.tcp.tcpAlgorithmClass = "TCPTahoe"
#**.tcp.tcpAlgorithmClass = "TCPNewReno"

## Network configuration

*.clientController.startTime = 72h

*.clientController.trackerAddress = "tracker"
*.clientController.trackerPort = 8082

#**.mac.txrate = 1000Mbps # bandwidth
#**.wlan.mac.rng-0 = 2
## channel physical parameters
*.channelControl.carrierFrequency = 2.4GHz
*.channelControl.pMax = 2mW
*.channelControl.sat = -73dBm
*.channelControl.alpha = 2
*.channelControl.propagationModel = "TwoRayGroundModel"#"FreeSpaceModel"
#*.channelcontrol.numChannels = 1

# nic settings
*.peer[*].wlan*.mgmtType = "Ieee80211MgmtAdhoc"
*.peer[*].wlan*.mgmt.frameCapacity = 10
*.peer[*].wlan*.mac.address = "auto"
*.peer[*].wlan*.mac.maxQueueSize = 15
*.peer[*].wlan*.mac.rtsThresholdBytes = 3000B
*.peer[*].wlan*.bitrate = 54Mbps
*.peer[*].wlan*.mac.basicBitrate = 54Mbps 
*.peer[*].wlan*.mac.retryLimit = 7
*.peer[*].wlan*.mac.cwMinData = 7
#*.peer[*].wlan*.mac.cwMinBroadcast = 31
*.peer[*].wlan*.mac.cwMinMulticast = 31
*.peer[*].wlan*.radio.transmitterPower = 2mW
#*.peer[*].wlan.radio.thermalNoise = -110dBm
*.peer[*].wlan*.radio.sensitivity=-73dBm
#*.peer[*].wlan.radio.pathLossAlpha = 2
#*.peer[*].wlan.radio.snirThreshold = 4dB


*.tracker.wlan[*].radio.transmitterPower = 0mW
#*.tracker.wlan[*].radio.thermalNoise = -110dBm
*.tracker.wlan[*].radio.sensitivity= 0dBm
**.drawCoverage = true

#*.mobilityModel = "StationaryMobility"#"SlawMobility","StationaryMobility, SlawMobility, StaticGridMobility"
**.mapName = "./maps/2000_500x500/2000_500x500_0.75_10"


## Parameters
**.swarmManager.normalRefreshInterval = 150s

**.swarmManager.numWant = 50 #<- Cantidad de pares que solicita el par (posible error con el timeout)
**.tracker.tcpApp[0].maxListSize = 50
**.tracker.tcpApp[0].contents = xmldoc("../simulations/BTContents.xml", "contentList")
**.tracker.tcpApp[0].typename="TrackerApp"
#**.tracker.tcpApp[0].dataTransferMode = "object"
**.tracker.tcpApp[0].dataTransferMode = "object"
#Posicion del tracker @display("p=450,450");


**.peer[*].tcpType = "peer"

# processing time configured with the histogram with 55 bins
*.peer[*].bitTorrentApp.bitTorrentClient.processingTimeHistogram = "../simulations/hist_55bin.dat"
*.peer[*].bitTorrentApp.bitTorrentClient.dataTransferMode = "object"
#Adaptación del contenido (*.torrent)
*.peer[*].bitTorrentApp.bitTorrentClient.contents = xmldoc("../simulations/BTContents.xml", "contentList")

*.peer[*].bitTorrentApp.bitTorrentClient.sizeX = 500
*.peer[*].bitTorrentApp.bitTorrentClient.sizeY = 500
*.peer[*].bitTorrentApp.bitTorrentClient.numberOfPeers = 25
*.peer[*].bitTorrentApp.bitTorrentClient.communicationRange = 50


*.peer[*].bitTorrentApp.bitTorrentClient.numWant = 50 #<- Cantidad de pares en la lista de pares aleatorios


####
#### Experiment for testing the simulation. The file size is small so that
#### the simulation ends quickly
####
[Config Test]
#sim-time-limit= 300s #5 minutos || 540s #9 minutos || 1h || 1day

sim-time-limit= 80h#-> 1.5h#2000s#BitHoc -> 2h

extends = Base
description = "Test the simulation with a small file for fast completion."
experiment-label = "Simulation Test"
measurement-label = "Peers: $peers, Rate: $rate"
repeat = 45

#Numero de pares
*.numPeers = 25

#Número de pares que no se moveran durante la simulación
*.staticPeerA = intuniform(1,6)
*.staticPeerB = intuniform(7,12)
*.staticPeerC = intuniform(13,18)
*.staticPeerD = intuniform(19,24)
#*.staticPeerA = intuniform(0,7)
#*.staticPeerB = intuniform(8,13)
#*.staticPeerC = intuniform(14,19)
#*.staticPeerD = intuniform(20,25)
#
#*.staticPeerE = intuniform(26,31)
#*.staticPeerF = intuniform(32,37)
#*.staticPeerG = intuniform(38,43)
#*.staticPeerH = intuniform(44,49)


# 10MB content
*.clientController.profile = xmldoc("../simulations/BTProfiles.xml","profileList/profile[@name='test_simple']")
*.clientController.numSeeders = 1
#EAM :: *.numPeers = ${peers=5,50,500}
num-rngs = 3
**.peer[*].bitTorrentApp.swarmManager.contentManager*.rng-0 = 1
**.peer[*].bitTorrentApp.swarmManager.choker*.rng-0 = 2
#**.tracker.**.rng-0 = 2
**.contentManager*.bytesSec = 1MiB#${rate=10KiB, 100KiB, 1MiB}
**.contentManager_*.burstSize = 50
# 70% or 30% of the peers will remain after completion

**.bitTorrentClient.numberOfActivePeers = 8#${active=3,5,25,50}
**.bitTorrentClient.numberOfPassivePeers = 4#${passive=2,5,25,50}

**.swarmManager.remainingSeeders = 1


#Recolección de medidas de desempeño
*.*.scalar-recording = true
*.*.vector-recording = true

**.bitTorrentClient**.vector-recording = true
**.ContentManager_100_percentDownloadTime.vector-recording = true
**.bitTorrentClient.Is_Anchor.scalar-recording = true
**.bitTorrentClient.Is_Anchor.vector-recording = true
 

**.scalar-recording = true
**.vector-recording = false


## Debug flags for printing messages to std::err
# WARNING: Enabling these messages may have a high impact on performance, and
# the processing of the log messages may take time and resources
**.bitTorrentClient.debugFlag = false
**.bitTorrentClient.subModulesDebugFlag = false
**.clientController.debugFlag = false
**.swarmManager.debugFlag = false
**.trackerApp.debugFlag = false

#Configuración de anclas en el escenario de simulación
# Si es ancla => 1, sino ancla => 0
#**.host[*].app.par = (parentIndex()>=2 && parentIndex()<=7 ? value : value2)
#**.peer[*].isAnchor = (parentIndex()>=0 && parentIndex()<=1 ? 1 : 0)
#**.peer[*].isAnchor = 0

#**.peer[*].isAnchor = (index()>=2 && index()<=4 ? 1 : 0)
#|| index() == staticPeerE 
# || index() == staticPeerE || index() == staticPeerF || index() == staticPeerG || index() == staticPeerH

**.peer[*].isAnchor = ( (index() == staticPeerA || index() == staticPeerB || index() == staticPeerC || index() == staticPeerD) ? 1 : 0)
